# +docs:section=Global

# Default values for cert-manager.
# This is a YAML-formatted file.
# Declare variables to be passed into your templates.
global:
  imagePullSecrets: []
  commonLabels: {}
  priorityClassName: "system-cluster-critical"

  rbac:
    create: true
    aggregateClusterRoles: true

  podSecurityPolicy:
    enabled: false
    useAppArmor: true

  logLevel: 2

  leaderElection:
    namespace: "cert-manager" #"kube-system" #"cert-manager"

installCRDs: false

crds:
  enabled: false
  keep: true

replicaCount: 1
strategy: {}

podDisruptionBudget:
  enabled: false

featureGates: ""

maxConcurrentChallenges: 60

# image:
  # The container registry to pull the manager image from.
  # +docs:property
  # registry: quay.io

  # The container image for the cert-manager controller.
  # +docs:property
  # repository: quay.io/jetstack/cert-manager-controller

  # Override the image tag to deploy by setting this variable.
  # If no value is set, the chart's appVersion is used.
  # +docs:property
  # tag: vX.Y.Z

  # Setting a digest will override any tag.
  # +docs:property
  # digest: sha256:0e072dddd1f7f8fc8909a2ca6f65e76c5f0d2fcfb8be47935ae3457e8bbceb20

  # Kubernetes imagePullPolicy on Deployment.
  # pullPolicy: IfNotPresent

# Override the namespace used to store DNS provider credentials etc. for ClusterIssuer
# resources. By default, the same namespace as cert-manager is deployed within is
# used. This namespace will not be automatically created by the Helm chart.
clusterResourceNamespace: ""
namespace: ""

serviceAccount:
  # Specifies whether a service account should be created.
  create: true

  annotations:
    eks.amazonaws.com/role-arn: aws:iam::227651627371:user/certManagerIAMUser
  # labels: {}

  # Automount API credentials for a Service Account.
  automountServiceAccountToken: true
# When this flag is enabled, secrets will be automatically removed when the certificate resource is deleted.
enableCertificateOwnerRef: false
config: {}

# A comma-separated string with the host and port of the recursive nameservers cert-manager should query.
dns01RecursiveNameservers: "8.8.8.8:53,1.1.1.1:53"

# Forces cert-manager to use only the recursive nameservers for verification.
# Enabling this option could cause the DNS01 self check to take longer owing to caching performed by the recursive nameservers.
dns01RecursiveNameserversOnly: false

# Option to disable cert-manager's build-in auto-approver. The auto-approver
# approves all CertificateRequests that reference issuers matching the 'approveSignerNames'
# option. This 'disableAutoApproval' option is useful when you want to make all approval decisions
# using a different approver (like approver-policy - https://github.com/cert-manager/approver-policy).
disableAutoApproval: false

# List of signer names that cert-manager will approve by default. CertificateRequests
# referencing these signer names will be auto-approved by cert-manager. Defaults to just
# approving the cert-manager.io Issuer and ClusterIssuer issuers. When set to an empty
# array, ALL issuers will be auto-approved by cert-manager. To disable the auto-approval,
# because eg. you are using approver-policy, you can enable 'disableAutoApproval'.
# ref: https://cert-manager.io/docs/concepts/certificaterequest/#approval
# +docs:property
approveSignerNames:
- issuers.cert-manager.io/*
- clusterissuers.cert-manager.io/*

extraArgs: []
# - --enable-gateway-api


# Additional environment variables to pass to cert-manager controller binary.
extraEnv: []
# - name: SOME_VAR
#   value: 'some value'

# Resources to provide to the cert-manager controller pod.
#
# For example:
#  requests:
#    cpu: 10m
#    memory: 32Mi
#
# For more information, see [Resource Management for Pods and Containers](https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/).
resources: {}

# Pod Security Context.
# For more information, see [Configure a Security Context for a Pod or Container](https://kubernetes.io/docs/tasks/configure-pod-container/security-context/).
# +docs:property
securityContext:
  runAsNonRoot: true
  seccompProfile:
    type: RuntimeDefault

# Container Security Context to be set on the controller component container.
# For more information, see [Configure a Security Context for a Pod or Container](https://kubernetes.io/docs/tasks/configure-pod-container/security-context/).
# +docs:property
containerSecurityContext:
  allowPrivilegeEscalation: false
  capabilities:
    drop:
    - ALL
  readOnlyRootFilesystem: true

# Additional volumes to add to the cert-manager controller pod.
# volumes: []

volumes:
- name: serviceaccount-token
  projected:
    defaultMode: 0444
    sources:
    - serviceAccountToken:
        expirationSeconds: 3607
        path: token
    - configMap:
        name: kube-root-ca.crt
        items:
        - key: ca.crt
          path: ca.crt
    - downwardAPI:
        items:
        - path: namespace
          fieldRef:
            apiVersion: v1
            fieldPath: metadata.namespace

# Additional volume mounts to add to the cert-manager controller container.
# volumeMounts: []

volumeMounts:
- mountPath: /var/run/secrets/kubernetes.io/serviceaccount
  name: serviceaccount-token
  readOnly: true

podLabels: {}

podDnsPolicy: None
podDnsConfig:
  nameservers:
  - 8.8.8.8
  - 1.1.1.1

hostAliases: []

nodeSelector:
  kubernetes.io/os: linux

ingressShim: {}

affinity: {}

tolerations: []

topologySpreadConstraints: []

livenessProbe:
  enabled: true
  initialDelaySeconds: 10
  periodSeconds: 10
  timeoutSeconds: 15
  successThreshold: 1
  failureThreshold: 8

enableServiceLinks: false


prometheus:
  enabled: true
  servicemonitor:
    enabled: true
    prometheusInstance: kube-prometheus-stack
    targetPort: 9402
    path: /metrics
    interval: 60s
    scrapeTimeout: 30s
    labels:
      prometheus.io/scrap-with: kube-prometheus-stack
      release: kube-prometheus-stack
    annotations: {}
    honorLabels: false
    endpointAdditionalProperties: {}

  # Note that you can not enable both PodMonitor and ServiceMonitor as they are mutually exclusive. Enabling both will result in a error.
  podmonitor:
    enabled: false
    prometheusInstance: default
    path: /metrics
    interval: 60s
    scrapeTimeout: 30s
    labels: {}
    annotations: {}
    honorLabels: false

    endpointAdditionalProperties: {}


webhook:
  replicaCount: 1
  timeoutSeconds: 30
  config: {}
  # For example:
  #  strategy:
  #    type: RollingUpdate
  #    rollingUpdate:
  #      maxSurge: 0
  #      maxUnavailable: 1
  strategy: {}
  securityContext:
    runAsNonRoot: true
    seccompProfile:
      type: RuntimeDefault

  containerSecurityContext:
    allowPrivilegeEscalation: false
    capabilities:
      drop:
      - ALL
    readOnlyRootFilesystem: true

  podDisruptionBudget:
    enabled: false

  validatingWebhookConfiguration:
    namespaceSelector:
      matchExpressions:
        - key: "cert-manager.io/disable-validation"
          operator: "NotIn"
          values:
            - "true"

  mutatingWebhookConfiguration:
    namespaceSelector: {}

  extraArgs:
    - --logging-format=json
  featureGates: ""
  resources: {}

  livenessProbe:
    failureThreshold: 3
    initialDelaySeconds: 60
    periodSeconds: 10
    successThreshold: 1
    timeoutSeconds: 1

  readinessProbe:
    failureThreshold: 3
    initialDelaySeconds: 5
    periodSeconds: 5
    successThreshold: 1
    timeoutSeconds: 1

  nodeSelector:
    kubernetes.io/os: linux
    # node-restriction.kubernetes.io/reserved-for: platform

  affinity: {}
  tolerations: []
  topologySpreadConstraints: []
  podLabels: {}
  serviceLabels: {}
  serviceIPFamilyPolicy: ""
  serviceIPFamilies: []

  # image:
    # The container registry to pull the webhook image from.
    # +docs:property
    # registry: quay.io

    # The container image for the cert-manager webhook
    # +docs:property
    # repository: quay.io/jetstack/cert-manager-webhook

    # Override the image tag to deploy by setting this variable.
    # If no value is set, the chart's appVersion will be used.
    # +docs:property
    # tag: vX.Y.Z

    # Setting a digest will override any tag
    # +docs:property
    # digest: sha256:0e072dddd1f7f8fc8909a2ca6f65e76c5f0d2fcfb8be47935ae3457e8bbceb20

    # Kubernetes imagePullPolicy on Deployment.
    # pullPolicy: IfNotPresent

  serviceAccount:
    create: true
    automountServiceAccountToken: true

  # Automounting API credentials for a particular pod.
  # +docs:property
  # automountServiceAccountToken: true

  # The port that the webhook listens on for requests.
  # In GKE private clusters, by default Kubernetes apiservers are allowed to
  # talk to the cluster nodes only on 443 and 10250. Configuring
  # securePort: 10250, therefore will work out-of-the-box without needing to add firewall
  # rules or requiring NET_BIND_SERVICE capabilities to bind port numbers <1000.
  securePort: 10260 #443 #10250 #10260 #10250

  hostNetwork: true

  serviceType: ClusterIP

  # Specify the load balancer IP for the created service.
  # +docs:property
  # loadBalancerIP: "10.10.10.10"

  # Overrides the mutating webhook and validating webhook so they reach the webhook
  # service using the `url` field instead of a service.
  url: {}
    # host:

  # Enables default network policies for webhooks.
  networkPolicy:
    # Create network policies for the webhooks.
    enabled: false

    ingress:
    - from:
      - ipBlock:
          cidr: 0.0.0.0/0

    egress:
    - ports:
      - port: 80
        protocol: TCP
      - port: 443
        protocol: TCP
      - port: 53
        protocol: TCP
      - port: 53
        protocol: UDP
      # On OpenShift and OKD, the Kubernetes API server listens on.
      # port 6443.
      - port: 6443
        protocol: TCP
      to:
      - ipBlock:
          cidr: 0.0.0.0/0

  # Additional volumes to add to the cert-manager controller pod.
  volumes: []

  # Additional volume mounts to add to the cert-manager controller container.
  volumeMounts: []
  enableServiceLinks: false

cainjector:
  enabled: true
  replicaCount: 1
  config: {}

  # For example:
  #  strategy:
  #    type: RollingUpdate
  #    rollingUpdate:
  #      maxSurge: 0
  #      maxUnavailable: 1
  strategy: {}

  securityContext:
    runAsNonRoot: true
    seccompProfile:
      type: RuntimeDefault

  containerSecurityContext:
    allowPrivilegeEscalation: false
    capabilities:
      drop:
      - ALL
    readOnlyRootFilesystem: true

  podDisruptionBudget:
    enabled: false

  extraArgs:
    - --logging-format=json
  # - --enable-profiling=true

  # extraArgs:
  # - --namespace=cert-manager
  # - --enable-certificates-data-source=false

  featureGates: ""

  # Resources to provide to the cert-manager cainjector pod.
  #
  # For example:
  #  requests:
  #    cpu: 10m
  #    memory: 32Mi
  #
  # For more information, see [Resource Management for Pods and Containers](https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/).
  resources: {}

  nodeSelector:
    kubernetes.io/os: linux
    # node-restriction.kubernetes.io/reserved-for: platform

  affinity: {}
  tolerations: []
  topologySpreadConstraints: []
  podLabels: {}
  serviceAccount:
    create: true
    automountServiceAccountToken: true

  volumes: []
  volumeMounts: []
  enableServiceLinks: false

# acmesolver:
  # image:
  #   # The container registry to pull the acmesolver image from.
  #   # +docs:property
  #   # registry: quay.io

  #   # The container image for the cert-manager acmesolver.
  #   # +docs:property
  #   repository: quay.io/jetstack/cert-manager-acmesolver

  #   # Override the image tag to deploy by setting this variable.
  #   # If no value is set, the chart's appVersion is used.
  #   # +docs:property
  #   # tag: vX.Y.Z

  #   # Setting a digest will override any tag.
  #   # +docs:property
  #   # digest: sha256:0e072dddd1f7f8fc8909a2ca6f65e76c5f0d2fcfb8be47935ae3457e8bbceb20

  #   # Kubernetes imagePullPolicy on Deployment.
  #   pullPolicy: IfNotPresent

# +docs:section=Startup API Check
# This startupapicheck is a Helm post-install hook that waits for the webhook
# endpoints to become available.
# The check is implemented using a Kubernetes Job - if you are injecting mesh
# sidecar proxies into cert-manager pods, ensure that they
# are not injected into this Job's pod. Otherwise, the installation may time out
# owing to the Job never being completed because the sidecar proxy does not exit.
# For more information, see [this note](https://github.com/cert-manager/cert-manager/pull/4414).

startupapicheck:
  # Enables the startup api check.
  enabled: true

  # Pod Security Context to be set on the startupapicheck component Pod.
  # For more information, see [Configure a Security Context for a Pod or Container](https://kubernetes.io/docs/tasks/configure-pod-container/security-context/).
  # +docs:property
  securityContext:
    runAsNonRoot: true
    seccompProfile:
      type: RuntimeDefault

  # Container Security Context to be set on the controller component container.
  # For more information, see [Configure a Security Context for a Pod or Container](https://kubernetes.io/docs/tasks/configure-pod-container/security-context/).
  # +docs:property
  containerSecurityContext:
    allowPrivilegeEscalation: false
    capabilities:
      drop:
      - ALL
    readOnlyRootFilesystem: true

  # Timeout for 'kubectl check api' command.
  timeout: 1m
  backoffLimit: 4

  jobAnnotations:
    helm.sh/hook: post-install
    helm.sh/hook-weight: "1"
    helm.sh/hook-delete-policy: before-hook-creation,hook-succeeded

  extraArgs:
  - -v

  # Resources to provide to the cert-manager controller pod.
  #
  # For example:
  #  requests:
  #    cpu: 10m
  #    memory: 32Mi
  #
  # For more information, see [Resource Management for Pods and Containers](https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/).
  resources: {}

  nodeSelector:
    kubernetes.io/os: linux
  affinity: {}
  tolerations: []
  podLabels: {}

  rbac:
    # annotations for the startup API Check job RBAC and PSP resources.
    # +docs:property
    annotations:
      helm.sh/hook: post-install
      helm.sh/hook-weight: "-5"
      helm.sh/hook-delete-policy: before-hook-creation,hook-succeeded

  serviceAccount:
    # Specifies whether a service account should be created.
    create: true

    annotations:
      helm.sh/hook: post-install
      helm.sh/hook-weight: "-5"
      helm.sh/hook-delete-policy: before-hook-creation,hook-succeeded

    automountServiceAccountToken: true

  volumes: []

  # Additional volume mounts to add to the cert-manager controller container.
  volumeMounts: []
  enableServiceLinks: false

extraObjects: []
